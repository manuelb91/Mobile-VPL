package it.unibz.mobilevpl.definition;

import java.util.HashMap;
import java.util.Map;

public class BlockDefinition {

	public static enum BlockType {
		CONTROL("control"), 
		DATA("data"), 
		EVENT("event"), 
		LOOK("look"), 
		MOTION("motion"), 
		OPERATOR("operator"), 
		PEN("pen"), 
		SENSING("sensing"), 
		SOUND("sound");
		
		private String value;
		
		private static final Map<String, BlockType> lookup = new HashMap<String, BlockType>();
        static {
            for (BlockType blockType : BlockType.values())
                lookup.put(blockType.getValue(), blockType);
        }
		
		private BlockType(String value) {
			this.value = value;
		}
		
		public String getValue() {
			return this.value;
		}
		
		public static BlockType get(String value) {
            return lookup.get(value);
        }
	}
	
	public static enum OperationType {
		WHEN_FALG_PRESSED(BlockType.EVENT.getValue(), "when_flag_pressed", false), 
		WHEN_SPRITE_CLICKED(BlockType.EVENT.getValue(), "when_sprite_clicked", false), 
		WAIT_FOR_SECONDS(BlockType.EVENT.getValue(), "wait_for_seconds", false), 
		REPEAT_N_TIMES(BlockType.EVENT.getValue(), "repeat_n_times", false), 
		REPEAT_FOREVER(BlockType.EVENT.getValue(), "repeat_forever", false), 
		BROADCAST_MESSAGE(BlockType.EVENT.getValue(), "broadcast_message", false), 
		BROADCAST_MESSAGE_AND_WAIT(BlockType.EVENT.getValue(), "broadcast_message_and_wait", false), 
		WHEN_MESSAGE_RECEIVED(BlockType.EVENT.getValue(), "when_message_received", false), 
		STOP_SCRIPT(BlockType.EVENT.getValue(), "stop_script", false), 
		STOP_ALL(BlockType.EVENT.getValue(), "stop_all", false),
		
		MOVEMENT(BlockType.MOTION.getValue(), "movement", false), 
		TURN_CLOCKWISE(BlockType.MOTION.getValue(), "turn_clockwise", false), 
		TURN_COUNTER_CLOCKWISE(BlockType.MOTION.getValue(), "turn_counter_clockwise", false), 
		POINT_DIRECTION(BlockType.MOTION.getValue(), "point_direction", false), 
		POINT_TOWARDS_TOUCH(BlockType.MOTION.getValue(), "point_towards_touch", false), 
		POINT_TOWARDS_SPRITE(BlockType.MOTION.getValue(), "point_towards_sprite", false),
		GO_TO_XY(BlockType.MOTION.getValue(), "go_to_xy", true), 
		GO_TO(BlockType.MOTION.getValue(), "go_to", false), 
		GLIDE_TO_XY_SECONDS(BlockType.MOTION.getValue(), "glide_to_xy_seconds", true), 
		CHANGE_X(BlockType.MOTION.getValue(), "change_x", true), 
		SET_X(BlockType.MOTION.getValue(), "set_x", true), 
		CHANGE_Y(BlockType.MOTION.getValue(), "change_y", true), 
		SET_Y(BlockType.MOTION.getValue(), "set_y", true), 
		BOUNCE_IF_ON_EDGE(BlockType.MOTION.getValue(), "bounce_if_on_edge", false), 
		ROTATION_STYLE(BlockType.MOTION.getValue(), "rotation_style", false),
		
		PLAY_SOUND(BlockType.SOUND.getValue(), "play_sound", false), 
		PLAY_SOUND_UNTIL_DONE(BlockType.SOUND.getValue(), "play_sound_until_done", false), 
		STOP_ALL_SOUNDS(BlockType.SOUND.getValue(), "stop_all_sounds", false), 
		CHANGE_VOLUME_BY(BlockType.SOUND.getValue(), "change_volume_by", false), 
		SET_VOLUME_TO_PERCENTAGE(BlockType.SOUND.getValue(), "set_volume_to_percentage", false), 
		
		IS_LESS_THAN("operator", "IsLessThan", false), IS_EQUAL_TO("operator", "IsEqualTo", false), 
		IS_GREATER_THAN("operator", "IsGreaterThan", false), 
		CONDITION_AND("operator", "ConditionAnd", false), CONDITION_OR("operator", "ConditionOr", false), 
		CONDITION_NOT("operator", "ConditionNot", false), 
		ADDITION("operator", "Addition", false), SUBTRACTION("operator", "Subtraction", false), 
		MULTIPLICATION("operator", "Multiplication", false), 
		DIVISION("operator", "Division", false), PICK_RANDOM_INTEGER("operator", "PickRandomInteger", false), 
		PICK_RANDOM_DECIMAL("operator", "PickRandomDecimal", false), JOIN_NUMBER("operator", "JoinNumber", false), 
		JOIN_TEXT("operator", "JoinText", false), 
		LETTER_OF_TEXT("operator", "LetterOfText", false), LETTER_OF_NUMBER("operator", "LetterOfNumber", false), 
		LENGTH_OF_NUMBER("operator", "LengthOfNumber", false), LENGTH_OF_TEXT("operator", "LengthOfText", false),
		MODULO("operator", "Modulo", false), 
		ROUND("operator", "Round", false), OPERATION_OF_ABS("operator", "OperationOfAbs", false), 
		OPERATION_OF_FLOOR("operator", "OperationOfFloor", false), 
		OPERATION_OF_CEILING("operator", "OperationOfCeiling", false), OPERATION_OF_SQRT("operator", "OperationOfSqrt", false), 
		OPERATION_OF_SIN("operator", "OperationOfSin", false), OPERATION_OF_COS("operator", "OperationOfCos", false), 
		OPERATION_OF_TAN("operator", "OperationOfTan", false), OPERATION_OF_ASIN("operator", "OperationOfAsin", false), 
		OPERATION_OF_ACOS("operator", "OperationOfAcos", false), OPERATION_OF_ATAN("operator", "OperationOfAtan", false), 
		OPERATION_OF_LN("operator", "OperationOfLn", false), OPERATION_OF_LOG("operator", "OperationOfLog", false), 
		OPERATION_OF_E("operator", "OperationOfE", false), OPERATION_OF_POW10("operator", "OperationOfPow10", false);
		
		private String value;
		private String type;
		private boolean containsValues;
		private boolean containsOptions;
		
		private static final Map<String, OperationType> lookup = new HashMap<String, OperationType>();
        static {
            for (OperationType operationType : OperationType.values())
                lookup.put(operationType.getValue(), operationType);
        }
		
		private OperationType(String type, String value, boolean containsValues) {
			this.type = type;
			this.value = value;
			this.containsValues = containsValues;
		}
		
		public String getValue() {
			return this.value;
		}
		
		public String getType() {
			return this.type;
		}
		
		public boolean getContainsValues() {
			return this.containsValues;
		}
		
		public static OperationType get(String value) {
            return lookup.get(value);
        }
	}
	
}
